17a18
> local jwt      = require("resty.jwt")
25d25
< local ngx_time = ngx.time
31,33d30
< local schema_def = require("apisix.schema_def")
< local jwt_parser = require("apisix.plugins.jwt-auth.parser")
< local auth_utils = require("apisix.utils.auth")
34a32
> 
53,67c51
<         },
<         anonymous_consumer = schema_def.anonymous_consumer_schema,
<         claims_to_verify = {
<             type = "array",
<             items = {
<                 type = "string",
<                 enum = {"exp","nbf"},
<             },
<             uniqueItems = true,
<             default = {"exp", "nbf"},
<         },
<         key_claim_name = {
<             type = "string",
<             default = "key"
<         },
---
>         }
75,82c59,60
<         key = {
<             type = "string",
<             minLength = 1,
<         },
<         secret = {
<             type = "string",
<             minLength = 1,
<         },
---
>         key = {type = "string"},
>         secret = {type = "string"},
85,99c63
<             enum = {
<                 "HS256",
<                 "HS384",
<                 "HS512",
<                 "RS256",
<                 "RS384",
<                 "RS512",
<                 "ES256",
<                 "ES384",
<                 "ES512",
<                 "PS256",
<                 "PS384",
<                 "PS512",
<                 "EdDSA",
<             },
---
>             enum = {"HS256", "HS512", "RS256", "ES256"},
119c83
<                             enum = {"HS256", "HS384", "HS512"},
---
>                             enum = {"HS256", "HS512"},
126,133c90
<                         public_key = {
<                             type = "string",
<                             minLength = 1,
<                         },
<                         private_key= {
<                             type = "string",
<                             minLength = 1,
<                         },
---
>                         public_key = {type = "string"},
135,146c92
<                             enum = {
<                                 "RS256",
<                                 "RS384",
<                                 "RS512",
<                                 "ES256",
<                                 "ES384",
<                                 "ES512",
<                                 "PS256",
<                                 "PS384",
<                                 "PS512",
<                                 "EdDSA",
<                             },
---
>                             enum = {"RS256", "ES256"},
149c95
<                     required = {"public_key", "private_key"},
---
>                     required = {"public_key"},
154c100
<     encrypt_fields = {"secret", "private_key"},
---
>     encrypt_fields = {"secret"},
183,185c129
<     local is_hs_alg = conf.algorithm:sub(1, 2) == "HS"
< 
<     if is_hs_alg and not conf.secret then
---
>     if conf.algorithm ~= "RS256" and conf.algorithm ~= "ES256" and not conf.secret then
193,203d136
<     if not is_hs_alg then
<         -- Possible options are a) public key is missing
<         -- b) private key is missing
<         if not conf.public_key then
<             return false, "missing valid public key"
<         end
<         if not conf.private_key then
<             return false, "missing valid private key"
<         end
<     end
< 
276c209
< local function get_secret(conf, consumer_name)
---
> local function get_secret(conf)
286,298c219,224
< 
< local function get_rsa_or_ecdsa_keypair(conf, consumer_name)
<     local public_key = conf.public_key
<     local private_key = conf.private_key
< 
<     if public_key and private_key then
<         return public_key, private_key
<     elseif public_key and not private_key then
<         return nil, nil, "missing private key"
<     elseif not public_key and private_key then
<         return nil, nil, "missing public key"
<     else
<         return nil, nil, "public and private keys are missing"
---
> local function get_auth_secret(auth_conf)
>     if not auth_conf.algorithm or auth_conf.algorithm == "HS256"
>             or auth_conf.algorithm == "HS512" then
>         return get_secret(auth_conf)
>     elseif auth_conf.algorithm == "RS256" or auth_conf.algorithm == "ES256"  then
>         return auth_conf.public_key
302,350c228
< 
< local function get_real_payload(key, auth_conf, payload, key_claim_name)
<     local real_payload = {
<         [key_claim_name] = key,
<         exp = ngx_time() + auth_conf.exp
<     }
<     if payload then
<         local extra_payload = core.json.decode(payload)
<         core.table.merge(real_payload, extra_payload)
<     end
<     return real_payload
< end
< 
< 
< local function get_auth_secret(consumer, is_private)
<     if not consumer.auth_conf.algorithm or consumer.auth_conf.algorithm:sub(1, 2) == "HS" then
<         return get_secret(consumer.auth_conf)
<     else
<         local public_key, private_key, err = get_rsa_or_ecdsa_keypair(consumer.auth_conf)
<         if is_private then
<             return private_key, err
<         end
<         return public_key, err
<     end
< end
< 
< 
< local function gen_jwt_header(consumer)
<     local x5c
<     if consumer.auth_conf.algorithm and consumer.auth_conf.algorithm:sub(1, 2) ~= "HS" then
<         local public_key, _, err = get_rsa_or_ecdsa_keypair(
<             consumer.auth_conf, consumer.username
<         )
<         if not public_key then
<             core.log.error("failed to sign jwt, err: ", err)
<             core.response.exit(503, "failed to sign jwt")
<         end
<         x5c = {public_key}
<     end
< 
<     return {
<         typ = "JWT",
<         alg = consumer.auth_conf.algorithm,
<         x5c = x5c
<     }
< end
< 
< 
< local function find_consumer(conf, ctx)
---
> function _M.rewrite(conf, ctx)
355c233
<         return nil, nil, "Missing JWT token in request"
---
>         return 401, {message = "Missing JWT token in request"}
358,364c236,240
<     local jwt, err = jwt_parser.new(jwt_token)
<     if not jwt then
<         if auth_utils.is_running_under_multi_auth(ctx) then
<             return nil, nil, "JWT token invalid " .. err
<         end
<         core.log.warn("JWT token invalid: ", err)
<         return nil, nil, "JWT token invalid"
---
>     local jwt_obj = jwt:load_jwt(jwt_token)
>     core.log.info("jwt object: ", core.json.delay_encode(jwt_obj))
>     if not jwt_obj.valid then
>         core.log.warn("JWT token invalid: ", jwt_obj.reason)
>         return 401, {message = "JWT token invalid"}
366d241
<     core.log.debug("parsed jwt object: ", core.json.delay_encode(jwt, true))
368,369c243
<     local key_claim_name = conf.key_claim_name
<     local user_key = jwt.payload and jwt.payload[key_claim_name]
---
>     local user_key = jwt_obj.payload and jwt_obj.payload.key
371c245
<         return nil, nil, "missing " .. key_claim_name .. " claim in JWT token"
---
>         return 401, {message = "missing user key in JWT token"}
374,381c248,250
<     local consumer, consumer_conf, err = consumer_mod.find_consumer(plugin_name, "key", user_key)
<     if not consumer then
<         local err = "failed to find consumer: " .. (err or "invalid user key")
<         if auth_utils.is_running_under_multi_auth(ctx) then
<             return nil, nil, err
<         end
<         core.log.warn(err)
<         return nil, nil, "Invalid user key in JWT token"
---
>     local consumer_conf = consumer_mod.plugin(plugin_name)
>     if not consumer_conf then
>         return 401, {message = "Missing related consumer"}
384,392c253
<     local auth_secret, err = get_auth_secret(consumer)
<     if not auth_secret then
<         err = "failed to retrieve secrets, err: " .. err
<         if auth_utils.is_running_under_multi_auth(ctx) then
<             return nil, nil, err
<         end
<         core.log.error(err)
<         return nil, nil, "failed to verify jwt"
<     end
---
>     local consumers = consumer_mod.consumers_kv(plugin_name, consumer_conf, "key")
394,422c255
<     -- Now verify the JWT signature
<     if not jwt:verify_signature(auth_secret) then
<         local err = "failed to verify jwt: signature mismatch: " .. jwt.signature
<         if auth_utils.is_running_under_multi_auth(ctx) then
<             return nil, nil, err
<         end
<         core.log.warn(err)
<         return nil, nil, "failed to verify jwt"
<     end
< 
<     -- Verify the JWT registered claims
<     local ok, err = jwt:verify_claims(conf.claims_to_verify, {
<         lifetime_grace_period = consumer.auth_conf.lifetime_grace_period
<     })
<     if not ok then
<         err = "failed to verify jwt: " .. err
<         if auth_utils.is_running_under_multi_auth(ctx) then
<             return nil, nil, err
<         end
<         core.log.error(err)
<         return nil, nil, "failed to verify jwt"
<     end
< 
<     return consumer, consumer_conf
< end
< 
< 
< function _M.rewrite(conf, ctx)
<     local consumer, consumer_conf, err = find_consumer(conf, ctx)
---
>     local consumer = consumers[user_key]
424,434c257
<         if not conf.anonymous_consumer then
<             return 401, { message = err }
<         end
<         consumer, consumer_conf, err = consumer_mod.get_anonymous_consumer(conf.anonymous_consumer)
<         if not consumer then
<             if auth_utils.is_running_under_multi_auth(ctx) then
<                 return 401, err
<             end
<             core.log.error(err)
<             return 401, { message = "Invalid user authorization"}
<         end
---
>         return 401, {message = "Invalid user key in JWT token"}
436d258
< 
439,467c261
<     consumer_mod.attach_consumer(ctx, consumer, consumer_conf)
<     core.log.info("hit jwt-auth rewrite")
< end
< 
< 
< local function gen_token()
<     local args = core.request.get_uri_args()
<     if not args or not args.key then
<         return core.response.exit(400)
<     end
< 
<     local key = args.key
<     local payload = args.payload
<     local key_claim_name = args.key_claim_name or "key"
< 
<     if payload then
<         payload = ngx.unescape_uri(payload)
<     end
< 
<     if not key then
<         return 401, {message = "Missing user key in request"}
<     end
< 
<     local consumer, _, _ = consumer_mod.find_consumer(plugin_name, "key", key)
<     if not consumer then
<         return core.response.exit(404)
<     end
< 
<     local auth_secret, err = get_auth_secret(consumer, true)
---
>     local auth_secret, err = get_auth_secret(consumer.auth_conf)
470c264
<         return core.response.exit(401)
---
>         return 503, {message = "failed to verify jwt"}
471a266,267
>     local claim_specs = jwt:get_default_validation_options(jwt_obj)
>     claim_specs.lifetime_grace_period = consumer.auth_conf.lifetime_grace_period
473,477c269,270
<     local jwt_header, err = gen_jwt_header(consumer)
<     if not jwt_header then
<         core.log.error("failed to generate jwt header: ", err)
<         return core.response.exit(503)
<     end
---
>     jwt_obj = jwt:verify_jwt_obj(auth_secret, jwt_obj, claim_specs)
>     core.log.info("jwt object: ", core.json.delay_encode(jwt_obj))
479,484c272,274
<     local real_payload = get_real_payload(key, consumer.auth_conf, payload, key_claim_name)
<     local jwt_token, err = jwt_parser.encode(consumer.auth_conf.algorithm, auth_secret,
<                                              jwt_header, real_payload)
<     if not jwt_token then
<         core.log.warn("failed to sign jwt: ", err)
<         return core.response.exit(500, {message = "failed to sign jwt"})
---
>     if not jwt_obj.verified then
>         core.log.warn("failed to verify jwt: ", jwt_obj.reason)
>         return 401, {message = "failed to verify jwt"}
487,498c277,278
<     return core.response.exit(200, jwt_token)
< end
< 
< 
< function _M.api()
<     return {
<         {
<             methods = {"GET"},
<             uri = "/apisix/plugin/jwt/sign",
<             handler = gen_token,
<         }
<     }
---
>     consumer_mod.attach_consumer(ctx, consumer, consumer_conf)
>     core.log.info("hit jwt-auth rewrite")
