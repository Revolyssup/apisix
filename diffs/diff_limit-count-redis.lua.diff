17c17
< local redis_new = require("resty.redis").new
---
> local redis     = require("apisix.utils.redis")
19d18
< local delayed_syncer = require("apisix.plugins.limit-count.delayed-syncer")
34c33,34
<     local ttl = redis.call('pttl', KEYS[1])
---
>     assert(tonumber(ARGV[3]) >= 1, "cost must be at least 1")
>     local ttl = redis.call('ttl', KEYS[1])
37c37
<         return {ARGV[1] - ARGV[3], ARGV[2] * 1000}
---
>         return {ARGV[1] - ARGV[3], ARGV[2]}
42,44d41
< local function redis_cli(conf)
<     local red = redis_new()
<     local timeout = conf.redis_timeout or 1000    -- 1sec
46,86d42
<     red:set_timeouts(timeout, timeout, timeout)
< 
<     local sock_opts = {
<         ssl = conf.redis_ssl,
<         ssl_verify = conf.redis_ssl_verify
<     }
< 
<     local ok, err = red:connect(conf.redis_host, conf.redis_port or 6379, sock_opts)
<     if not ok then
<         return false, err
<     end
< 
<     local count
<     count, err = red:get_reused_times()
<     if 0 == count then
<         if conf.redis_password and conf.redis_password ~= '' then
<             local ok, err
<             if conf.redis_username then
<                 ok, err = red:auth(conf.redis_username, conf.redis_password)
<             else
<                 ok, err = red:auth(conf.redis_password)
<             end
<             if not ok then
<                 return nil, err
<             end
<         end
< 
<         -- select db
<         if conf.redis_database ~= 0 then
<             local ok, err = red:select(conf.redis_database)
<             if not ok then
<                 return false, "failed to change redis db, err: " .. err
<             end
<         end
<     elseif err then
<         -- core.log.info(" err: ", err)
<         return nil, err
<     end
<     return red, nil
< end
< 
96d51
<     self.delayed_syncer = delayed_syncer.new(limit, window, conf, self)
100,111d54
< function _M.incoming_delayed(self, key, cost, syncer_id)
<     core.log.info("delayed sync to redis") -- for sanity test
<     local remaining, reset, err = self.delayed_syncer:delayed_sync(key, cost, syncer_id)
<     if not remaining then
<         return nil, err, 0
<     end
<     if remaining < 0 then
<         return nil, "rejected", reset
<     end
<     return 0, remaining, reset
< end
< 
114c57
<     local red, err = redis_cli(conf)
---
>     local red, err = redis.new(conf)
132c75
<     ttl = res[2] / 1000.0
---
>     ttl = res[2]
