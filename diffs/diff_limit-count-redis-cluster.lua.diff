18c18
< local rediscluster = require("resty.rediscluster")
---
> local redis_cluster = require("apisix.utils.rediscluster")
20d19
< local delayed_syncer = require("apisix.plugins.limit-count.delayed-syncer")
23d21
< local ipairs = ipairs
34c32,33
<     local ttl = redis.call('pttl', KEYS[1])
---
>     assert(tonumber(ARGV[3]) >= 1, "cost must be at least 1")
>     local ttl = redis.call('ttl', KEYS[1])
37c36
<         return {ARGV[1] - ARGV[3], ARGV[2] * 1000}
---
>         return {ARGV[1] - ARGV[3], ARGV[2]}
43,75d41
< local function new_redis_cluster(conf)
<     local config = {
<         -- can set different name for different redis cluster
<         name = conf.redis_cluster_name,
<         serv_list = {},
<         read_timeout = conf.redis_timeout,
<         auth = conf.redis_password,
<         dict_name = "plugin-limit-count-redis-cluster-slot-lock",
<         connect_opts = {
<             ssl = conf.redis_cluster_ssl,
<             ssl_verify = conf.redis_cluster_ssl_verify,
<         }
<     }
< 
<     for i, conf_item in ipairs(conf.redis_cluster_nodes) do
<         local host, port, err = core.utils.parse_addr(conf_item)
<         if err then
<             return nil, "failed to parse address: " .. conf_item
<                         .. " err: " .. err
<         end
< 
<         config.serv_list[i] = {ip = host, port = port}
<     end
< 
<     local red_cli, err = rediscluster:new(config)
<     if not red_cli then
<         return nil, "failed to new redis cluster: " .. err
<     end
< 
<     return red_cli
< end
< 
< 
77c43
<     local red_cli, err = new_redis_cluster(conf)
---
>     local red_cli, err = redis_cluster.new(conf, "plugin-limit-count-redis-cluster-slot-lock")
89c55
<     self.delayed_syncer = delayed_syncer.new(limit, window, conf, self)
---
> 
93,103d58
< function _M.incoming_delayed(self, key, cost, syncer_id)
<     core.log.info("delayed sync to redis-cluster") -- for sanity test
<     local remaining, reset, err = self.delayed_syncer:delayed_sync(key, cost, syncer_id)
<     if not remaining then
<         return nil, err, 0
<     end
<     if remaining < 0 then
<         return nil, "rejected", reset
<     end
<     return 0, remaining, reset
< end
119c74
<     ttl = res[2] / 1000.0
---
>     ttl = res[2]
